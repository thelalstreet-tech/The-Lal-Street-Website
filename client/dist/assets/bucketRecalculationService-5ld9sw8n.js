import{c as o,l as t,a as s,s as u,b as i,u as d}from"./index-DxYZk9_E.js";import"./react-vendor-Dazix4UH.js";const g=5;async function f(e){try{t.log(`[Recalculation] Starting recalculation for bucket: ${e.name}`);const a=await i(e.funds),r={...e,performance:{...e.performance,rollingReturns:a.rollingReturns,analysisStartDate:a.analysisStartDate,analysisEndDate:a.analysisEndDate,totalPeriods:a.totalPeriods},lastCalculationDate:new Date().toISOString(),updatedAt:new Date().toISOString()};return await d(e.id,r),t.log(`[Recalculation] Successfully recalculated bucket: ${e.name}`),r}catch(a){return console.error(`[Recalculation] Error recalculating bucket ${e.name}:`,a.message),null}}async function m(){const e={checked:0,recalculated:0,skipped:0,errors:0};try{const a=await o();if(!a.isHealthy)return t.log("[Recalculation] Server is not healthy, skipping recalculation"),e;if(a.isLoading)return t.log("[Recalculation] Server is under load, skipping recalculation"),e;t.log("[Recalculation] Server is healthy, checking buckets...");const l=(await s(!1)).filter(c=>(e.checked++,c.isActive&&u(c.lastCalculationDate,g)));if(l.length===0)return t.log("[Recalculation] No buckets need recalculation"),e;t.log(`[Recalculation] Found ${l.length} buckets that need recalculation`);for(const c of l)await f(c)?e.recalculated++:e.errors++,await new Promise(n=>setTimeout(n,1e3));return t.log(`[Recalculation] Completed: ${e.recalculated} recalculated, ${e.errors} errors`),e}catch(a){return console.error("[Recalculation] Error in checkAndRecalculateBuckets:",a.message),e}}export{m as checkAndRecalculateBuckets};
